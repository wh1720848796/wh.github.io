<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第10章 数据聚合与分组运算 | 饮茶</title><meta name="author" content="Yincha"><meta name="copyright" content="Yincha"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。 关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便">
<meta property="og:type" content="article">
<meta property="og:title" content="第10章 数据聚合与分组运算">
<meta property="og:url" content="http://wh1720848796.github.io/post/b0f8d937.html">
<meta property="og:site_name" content="饮茶">
<meta property="og:description" content="对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。 关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wh1720848796.github.io/img/HatsuneMiku5.png">
<meta property="article:published_time" content="2023-04-22T11:59:02.000Z">
<meta property="article:modified_time" content="2023-04-22T12:11:17.798Z">
<meta property="article:author" content="Yincha">
<meta property="article:tag" content="学习NumPy和Pandas">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wh1720848796.github.io/img/HatsuneMiku5.png"><link rel="shortcut icon" href="/img/EmiyaShirou.png"><link rel="canonical" href="http://wh1720848796.github.io/post/b0f8d937.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"NRN3QGVHM9","apiKey":"69a66e43b5218453c7420d0e818ebed9","indexName":"wh-code","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第10章 数据聚合与分组运算',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-22 20:11:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/EmiyaShirou.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/HatsuneMiku5.png')"><nav id="nav"><span id="blog-info"><a href="/" title="饮茶"><span class="site-name">饮茶</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第10章 数据聚合与分组运算</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-22T11:59:02.000Z" title="发表于 2023-04-22 19:59:02">2023-04-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-22T12:11:17.798Z" title="更新于 2023-04-22 20:11:17">2023-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span id="" data-flag-title="第10章 数据聚合与分组运算"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的gruopby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。</p>
<p>关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：</p>
<ul>
<li>使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。</li>
<li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li>
<li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li>
<li>计算透视表或交叉表。</li>
<li>执行分位数分析以及其它统计分组分析。</li>
</ul>
<blockquote>
<p>笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），本书将在第11章中单独对其进行讲解。</p>
</blockquote>
<h1 id="10-1-GroupBy机制"><a href="#10-1-GroupBy机制" class="headerlink" title="10.1 GroupBy机制"></a>10.1 GroupBy机制</h1><p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语”split-apply-combine”（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。</p>
<p><img src="/post/b0f8d937/7178691-e5c671e09ecf94be.png" alt="图10-1 分组聚合演示"></p>
<p>分组键可以有多种形式，且类型不必相同：</p>
<ul>
<li>列表或数组，其长度与待分组的轴一样。</li>
<li>表示DataFrame某个列名的值。</li>
<li>字典或Series，给出待分组轴上的值与分组名之间的对应关系。</li>
<li>函数，用于处理轴索引或索引中的各个标签。</li>
</ul>
<p>注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span> : [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;key2&#x27;</span> : [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   ....:                    <span class="string">&#x27;data1&#x27;</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">&#x27;data2&#x27;</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure>

<p>假设你想要按key1进行分组，并计算data1列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问data1，并根据key1调用groupby：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped</span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa31537390</span>&gt;</span><br></pre></td></tr></table></figure>

<p>变量grouped是一个GroupBy对象。它实际上还没有进行任何计算，只是含有一些有关分组键df[‘key1’]的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用GroupBy的mean方法来计算分组平均值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">0.746672</span></span><br><span class="line">b   -<span class="number">0.537585</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>稍后我将详细讲解.mean()的调用过程。这里最重要的是，数据（Series）根据分组键进行了聚合，产生了一个新的Series，其索引为key1列中的唯一值。之所以结果中索引的名称为key1，是因为原始DataFrame的列df[‘key1’]就叫这个名字。</p>
<p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df[<span class="string">&#x27;data1&#x27;</span>].groupby([df[<span class="string">&#x27;key1&#x27;</span>], df[<span class="string">&#x27;key2&#x27;</span>]]).mean()</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    -<span class="number">0.519439</span></span><br><span class="line">      two    -<span class="number">0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>这里，我通过两个键对数据进行了分组，得到的Series具有一个层次化索引（由唯一的键对组成）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: means.unstack()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">key2       one       two</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">0.880536</span>  <span class="number">0.478943</span></span><br><span class="line">b    -<span class="number">0.519439</span> -<span class="number">0.555730</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，分组键均为Series。实际上，分组键可以是任何长度适当的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">18</span>]: states = np.array([<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: years = np.array([<span class="number">2005</span>, <span class="number">2005</span>, <span class="number">2006</span>, <span class="number">2005</span>, <span class="number">2006</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: df[<span class="string">&#x27;data1&#x27;</span>].groupby([states, years]).mean()</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">California  <span class="number">2005</span>    <span class="number">0.478943</span></span><br><span class="line">            <span class="number">2006</span>   -<span class="number">0.519439</span></span><br><span class="line">Ohio        <span class="number">2005</span>   -<span class="number">0.380219</span></span><br><span class="line">            <span class="number">2006</span>    <span class="number">1.965781</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>通常，分组信息就位于相同的要处理DataFrame中。这里，你还可以将列名（可以是字符串、数字或其他Python对象）用作分组键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: df.groupby(<span class="string">&#x27;key1&#x27;</span>).mean()</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.746672</span>  <span class="number">0.910916</span></span><br><span class="line">b    -<span class="number">0.537585</span>  <span class="number">0.525384</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).mean()</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">              data1     data2</span><br><span class="line">key1 key2                    </span><br><span class="line">a    one   <span class="number">0.880536</span>  <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line">b    one  -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line">     two  -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>你可能已经注意到了，第一个例子在执行df.groupby(‘key1’).mean()时，结果中没有key2列。这是因为df[‘key2’]不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿groupby做什么，都有可能会用到GroupBy的size方法，它可以返回一个含有分组大小的Series：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]).size()</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">2</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">b     one     <span class="number">1</span></span><br><span class="line">      two     <span class="number">1</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h2 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h2><p>GroupBy对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">for</span> name, group <span class="keyword">in</span> df.groupby(<span class="string">&#x27;key1&#x27;</span>):</span><br><span class="line">   ....:     <span class="built_in">print</span>(name)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">a</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">b</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: <span class="keyword">for</span> (k1, k2), group <span class="keyword">in</span> df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]):</span><br><span class="line">   ....:     <span class="built_in">print</span>((k1, k2))</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;one&#x27;</span>)</span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line">     data1     data2 key1 key2</span><br><span class="line"><span class="number">3</span> -<span class="number">0.55573</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">26</span>]: pieces = <span class="built_in">dict</span>(<span class="built_in">list</span>(df.groupby(<span class="string">&#x27;key1&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: pieces[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br></pre></td></tr></table></figure>

<p>groupby默认是在axis=0上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的df来说，我们可以根据dtype对列进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: df.dtypes</span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">data1    float64</span><br><span class="line">data2    float64</span><br><span class="line">key1      <span class="built_in">object</span></span><br><span class="line">key2      <span class="built_in">object</span></span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: grouped = df.groupby(df.dtypes, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>可以如下打印分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: <span class="keyword">for</span> dtype, group <span class="keyword">in</span> grouped:</span><br><span class="line">   ....:     <span class="built_in">print</span>(dtype)</span><br><span class="line">   ....:     <span class="built_in">print</span>(group)</span><br><span class="line">   ....:</span><br><span class="line">float64</span><br><span class="line">      data1     data2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span></span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span></span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span></span><br><span class="line"><span class="built_in">object</span></span><br><span class="line">  key1 key2</span><br><span class="line"><span class="number">0</span>    a  one</span><br><span class="line"><span class="number">1</span>    a  two</span><br><span class="line"><span class="number">2</span>    b  one</span><br><span class="line"><span class="number">3</span>    b  two</span><br><span class="line"><span class="number">4</span>    a  one</span><br></pre></td></tr></table></figure>

<h2 id="选取一列或列的子集"><a href="#选取一列或列的子集" class="headerlink" title="选取一列或列的子集"></a>选取一列或列的子集</h2><p>对于由DataFrame产生的GroupBy对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[<span class="string">&#x27;data1&#x27;</span>]</span><br><span class="line">df.groupby(<span class="string">&#x27;key1&#x27;</span>)[[<span class="string">&#x27;data2&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<p>是以下代码的语法糖：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;data1&#x27;</span>].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br><span class="line">df[[<span class="string">&#x27;data2&#x27;</span>]].groupby(df[<span class="string">&#x27;key1&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算data2列的平均值并以DataFrame形式得到结果，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[[<span class="string">&#x27;data2&#x27;</span>]].mean()</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">              data2</span><br><span class="line">key1 key2          </span><br><span class="line">a    one   <span class="number">1.319920</span></span><br><span class="line">     two   <span class="number">0.092908</span></span><br><span class="line">b    one   <span class="number">0.281746</span></span><br><span class="line">     two   <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>这种索引操作所返回的对象是一个已分组的DataFrame（如果传入的是列表或数组）或已分组的Series（如果传入的是标量形式的单个列名）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: s_grouped = df.groupby([<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>])[<span class="string">&#x27;data2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: s_grouped</span><br><span class="line">Out[<span class="number">33</span>]: &lt;pandas.core.groupby.SeriesGroupBy <span class="built_in">object</span> at <span class="number">0x7faa30c78da0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: s_grouped.mean()</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">1.319920</span></span><br><span class="line">      two     <span class="number">0.092908</span></span><br><span class="line">b     one     <span class="number">0.281746</span></span><br><span class="line">      two     <span class="number">0.769023</span></span><br><span class="line">Name: data2, dtype: float64</span><br></pre></td></tr></table></figure>

<p>##通过字典或Series进行分组<br>除数组以外，分组信息还可以其他形式存在。来看另一个示例DataFrame：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">   ....:                       index=[<span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Wes&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Travis&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line">Wes    -<span class="number">0.539741</span>       NaN       NaN -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>

<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">38</span>]: mapping = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">   ....:            <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;e&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;f&#x27;</span> : <span class="string">&#x27;orange&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以将这个字典传给groupby，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: by_column = people.groupby(mapping, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: by_column.<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">            blue       red</span><br><span class="line">Joe     <span class="number">0.503905</span>  <span class="number">1.063885</span></span><br><span class="line">Steve   <span class="number">1.297183</span> -<span class="number">1.553778</span></span><br><span class="line">Wes    -<span class="number">1.021228</span> -<span class="number">1.116829</span></span><br><span class="line">Jim     <span class="number">0.524712</span>  <span class="number">1.770545</span></span><br><span class="line">Travis -<span class="number">4.230992</span> -<span class="number">2.405455</span></span><br></pre></td></tr></table></figure>

<p>Series也有同样的功能，它可以被看做一个固定大小的映射：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: map_series = pd.Series(mapping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: map_series</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">a       red</span><br><span class="line">b       red</span><br><span class="line">c      blue</span><br><span class="line">d      blue</span><br><span class="line">e       red</span><br><span class="line">f    orange</span><br><span class="line">dtype: <span class="built_in">object</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: people.groupby(map_series, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">        blue  red</span><br><span class="line">Joe        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Steve      <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Wes        <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">Jim        <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">Travis     <span class="number">2</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>##通过函数进行分组<br>比起使用字典或Series，使用Python函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例DataFrame为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入len函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(<span class="built_in">len</span>).<span class="built_in">sum</span>()</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> -<span class="number">0.993608</span>  <span class="number">0.798764</span> -<span class="number">0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>

<p>将函数跟数组、列表、字典、Series混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">45</span>]: key_list = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: people.groupby([<span class="built_in">len</span>, key_list]).<span class="built_in">min</span>()</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">              a         b         c         d         e</span><br><span class="line"><span class="number">3</span> one -<span class="number">0.539741</span> -<span class="number">1.296221</span>  <span class="number">0.274992</span> -<span class="number">1.021228</span> -<span class="number">0.577087</span></span><br><span class="line">  two  <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line"><span class="number">5</span> one  <span class="number">0.886429</span> -<span class="number">2.001637</span> -<span class="number">0.371843</span>  <span class="number">1.669025</span> -<span class="number">0.438570</span></span><br><span class="line"><span class="number">6</span> two -<span class="number">0.713544</span> -<span class="number">0.831154</span> -<span class="number">2.370232</span> -<span class="number">1.860761</span> -<span class="number">0.860757</span></span><br></pre></td></tr></table></figure>

<h2 id="根据索引级别分组"><a href="#根据索引级别分组" class="headerlink" title="根据索引级别分组"></a>根据索引级别分组</h2><p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">47</span>]: columns = pd.MultiIndex.from_arrays([[<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>],</span><br><span class="line">   ....:                                     [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]],</span><br><span class="line">   ....:                                     names=[<span class="string">&#x27;cty&#x27;</span>, <span class="string">&#x27;tenor&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: hier_df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">5</span>), columns=columns)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: hier_df</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">cty          US                            JP          </span><br><span class="line">tenor         <span class="number">1</span>         <span class="number">3</span>         <span class="number">5</span>         <span class="number">1</span>         <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0.560145</span> -<span class="number">1.265934</span>  <span class="number">0.119827</span> -<span class="number">1.063512</span>  <span class="number">0.332883</span></span><br><span class="line"><span class="number">1</span>     -<span class="number">2.359419</span> -<span class="number">0.199543</span> -<span class="number">1.541996</span> -<span class="number">0.970736</span> -<span class="number">1.307030</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0.286350</span>  <span class="number">0.377984</span> -<span class="number">0.753887</span>  <span class="number">0.331286</span>  <span class="number">1.349742</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0.069877</span>  <span class="number">0.246674</span> -<span class="number">0.011862</span>  <span class="number">1.004812</span>  <span class="number">1.327195</span></span><br></pre></td></tr></table></figure>

<p>要根据级别分组，使用level关键字传递级别序号或名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: hier_df.groupby(level=<span class="string">&#x27;cty&#x27;</span>, axis=<span class="number">1</span>).count()</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">cty  JP  US</span><br><span class="line"><span class="number">0</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="10-2-数据聚合"><a href="#10-2-数据聚合" class="headerlink" title="10.2 数据聚合"></a>10.2 数据聚合</h1><p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如mean、count、min以及sum等。你可能想知道在GroupBy对象上调用mean()时究竟发生了什么。许多常见的聚合运算（如表10-1所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。</p>
<p><img src="/post/b0f8d937/7178691-ba8de524e08b1b6f.png" alt="表10-1 经过优化的groupby方法"></p>
<p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，quantile可以计算Series或DataFrame列的样本分位数。</p>
<p>虽然quantile并没有明确地实现于GroupBy，但它是一个Series方法，所以这里是能用的。实际上，GroupBy会高效地对Series进行切片，然后对各片调用piece.quantile(0.9)，最后将这些结果组装成最终结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: df</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> -<span class="number">0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> -<span class="number">0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> -<span class="number">0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: grouped = df.groupby(<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: grouped[<span class="string">&#x27;data1&#x27;</span>].quantile(<span class="number">0.9</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">key1</span><br><span class="line">a    <span class="number">1.668413</span></span><br><span class="line">b   -<span class="number">0.523068</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure>

<p>如果要使用你自己的聚合函数，只需将其传入aggregate或agg方法即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="keyword">def</span> <span class="title function_">peak_to_peak</span>(<span class="params">arr</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> arr.<span class="built_in">max</span>() - arr.<span class="built_in">min</span>()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br></pre></td></tr></table></figure>

<p>你可能注意到注意，有些方法（如describe）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: grouped.describe()</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line">     data1                                                              \</span><br><span class="line">     count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a      <span class="number">3.0</span>  <span class="number">0.746672</span>  <span class="number">1.109736</span> -<span class="number">0.204708</span>  <span class="number">0.137118</span>  <span class="number">0.478943</span>  <span class="number">1.222362</span>   </span><br><span class="line">b      <span class="number">2.0</span> -<span class="number">0.537585</span>  <span class="number">0.025662</span> -<span class="number">0.555730</span> -<span class="number">0.546657</span> -<span class="number">0.537585</span> -<span class="number">0.528512</span>   </span><br><span class="line">               data2                                                    \</span><br><span class="line"><span class="built_in">max</span> count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%   </span><br><span class="line">key1                                                                     </span><br><span class="line">a     <span class="number">1.965781</span>   <span class="number">3.0</span>  <span class="number">0.910916</span>  <span class="number">0.712217</span>  <span class="number">0.092908</span>  <span class="number">0.669671</span>  <span class="number">1.246435</span>   </span><br><span class="line">b    -<span class="number">0.519439</span>   <span class="number">2.0</span>  <span class="number">0.525384</span>  <span class="number">0.344556</span>  <span class="number">0.281746</span>  <span class="number">0.403565</span>  <span class="number">0.525384</span>   </span><br><span class="line">                          </span><br><span class="line">           <span class="number">75</span>%       <span class="built_in">max</span>  </span><br><span class="line">key1                      </span><br><span class="line">a     <span class="number">1.319920</span>  <span class="number">1.393406</span>  </span><br><span class="line">b     <span class="number">0.647203</span>  <span class="number">0.769023</span></span><br></pre></td></tr></table></figure>

<p>在后面的10.3节，我将详细说明这到底是怎么回事。</p>
<blockquote>
<p>笔记：自定义聚合函数要比表10-1中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
</blockquote>
<h2 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h2><p>回到前面小费的例子。使用read_csv导入数据之后，我们添加了一个小费百分比的列tip_pct：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">57</span>]: tips = pd.read_csv(<span class="string">&#x27;examples/tips.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add tip percentage of total bill</span></span><br><span class="line">In [<span class="number">58</span>]: tips[<span class="string">&#x27;tip_pct&#x27;</span>] = tips[<span class="string">&#x27;tip&#x27;</span>] / tips[<span class="string">&#x27;total_bill&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: tips[:<span class="number">6</span>]</span><br><span class="line">Out[<span class="number">59</span>]: </span><br><span class="line">   total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">0</span>       <span class="number">16.99</span>  <span class="number">1.01</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.059447</span></span><br><span class="line"><span class="number">1</span>       <span class="number">10.34</span>  <span class="number">1.66</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.160542</span></span><br><span class="line"><span class="number">2</span>       <span class="number">21.01</span>  <span class="number">3.50</span>     No  Sun  Dinner     <span class="number">3</span>  <span class="number">0.166587</span></span><br><span class="line"><span class="number">3</span>       <span class="number">23.68</span>  <span class="number">3.31</span>     No  Sun  Dinner     <span class="number">2</span>  <span class="number">0.139780</span></span><br><span class="line"><span class="number">4</span>       <span class="number">24.59</span>  <span class="number">3.61</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.146808</span></span><br><span class="line"><span class="number">5</span>       <span class="number">25.29</span>  <span class="number">4.71</span>     No  Sun  Dinner     <span class="number">4</span>  <span class="number">0.186240</span></span><br></pre></td></tr></table></figure>

<p>你已经看到，对Series或DataFrame列的聚合运算其实就是使用aggregate（使用自定义函数）或调用诸如mean、std之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和smoker对tips进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">60</span>]: grouped = tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>注意，对于表10-1中的那些描述统计，可以将函数名以字符串的形式传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: grouped_pct = grouped[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: grouped_pct.agg(<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">day   smoker</span><br><span class="line">Fri   No        <span class="number">0.151650</span></span><br><span class="line">      Yes       <span class="number">0.174783</span></span><br><span class="line">Sat   No        <span class="number">0.158048</span></span><br><span class="line">      Yes       <span class="number">0.147906</span></span><br><span class="line">Sun   No        <span class="number">0.160113</span></span><br><span class="line">      Yes       <span class="number">0.187250</span></span><br><span class="line">Thur  No        <span class="number">0.160298</span></span><br><span class="line">      Yes       <span class="number">0.163863</span></span><br><span class="line">Name: tip_pct, dtype: float64</span><br></pre></td></tr></table></figure>

<p>如果传入一组函数或函数名，得到的DataFrame的列就会以相应的函数命名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">63</span>]: grouped_pct.agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>, peak_to_peak])</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">                 mean       std  peak_to_peak</span><br><span class="line">day  smoker                                  </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span>      <span class="number">0.067349</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span>      <span class="number">0.159925</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span>      <span class="number">0.235193</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span>      <span class="number">0.290095</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span>      <span class="number">0.193226</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span>      <span class="number">0.644685</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span>      <span class="number">0.193350</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span>      <span class="number">0.151240</span></span><br></pre></td></tr></table></figure>

<p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p>
<p>你并非一定要接受GroupBy自动给出的那些列名，特别是lambda函数，它们的名称是’<lambda>‘，这样的辨识度就很低了（通过函数的__name__属性看看就知道了）。因此，如果传入的是一个由(name,function)元组组成的列表，则各元组的第一个元素就会被用作DataFrame的列名（可以将这种二元元组列表看做一个有序映射）：</lambda></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">64</span>]: grouped_pct.agg([(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, np.std)])</span><br><span class="line">Out[<span class="number">64</span>]: </span><br><span class="line">                  foo       bar</span><br><span class="line">day  smoker                    </span><br><span class="line">Fri  No      <span class="number">0.151650</span>  <span class="number">0.028123</span></span><br><span class="line">     Yes     <span class="number">0.174783</span>  <span class="number">0.051293</span></span><br><span class="line">Sat  No      <span class="number">0.158048</span>  <span class="number">0.039767</span></span><br><span class="line">     Yes     <span class="number">0.147906</span>  <span class="number">0.061375</span></span><br><span class="line">Sun  No      <span class="number">0.160113</span>  <span class="number">0.042347</span></span><br><span class="line">     Yes     <span class="number">0.187250</span>  <span class="number">0.154134</span></span><br><span class="line">Thur No      <span class="number">0.160298</span>  <span class="number">0.038774</span></span><br><span class="line">     Yes     <span class="number">0.163863</span>  <span class="number">0.039389</span></span><br></pre></td></tr></table></figure>

<p>对于DataFrame，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对tip_pct和total_bill列计算三个统计信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: functions = [<span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: result = grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(functions)</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: result</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">            tip_pct                     total_bill                  </span><br><span class="line">              count      mean       <span class="built_in">max</span>      count       mean    <span class="built_in">max</span></span><br><span class="line">day  smoker                                                         </span><br><span class="line">Fri  No           <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span>          <span class="number">4</span>  <span class="number">18.420000</span>  <span class="number">22.75</span></span><br><span class="line">     Yes         <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span>         <span class="number">15</span>  <span class="number">16.813333</span>  <span class="number">40.17</span></span><br><span class="line">Sat  No          <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span>         <span class="number">45</span>  <span class="number">19.661778</span>  <span class="number">48.33</span></span><br><span class="line">     Yes         <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span>         <span class="number">42</span>  <span class="number">21.276667</span>  <span class="number">50.81</span></span><br><span class="line">Sun  No          <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span>         <span class="number">57</span>  <span class="number">20.506667</span>  <span class="number">48.17</span></span><br><span class="line">     Yes         <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span>         <span class="number">19</span>  <span class="number">24.120000</span>  <span class="number">45.35</span></span><br><span class="line">Thur No          <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span>         <span class="number">45</span>  <span class="number">17.113111</span>  <span class="number">41.19</span></span><br><span class="line">     Yes         <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span>         <span class="number">17</span>  <span class="number">19.190588</span>  <span class="number">43.11</span></span><br></pre></td></tr></table></figure>

<p>如你所见，结果DataFrame拥有层次化的列，这相当于分别对各列进行聚合，然后用concat将结果组装到一起，使用列名用作keys参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">68</span>]: result[<span class="string">&#x27;tip_pct&#x27;</span>]</span><br><span class="line">Out[<span class="number">68</span>]: </span><br><span class="line">             count      mean       <span class="built_in">max</span></span><br><span class="line">day  smoker                           </span><br><span class="line">Fri  No          <span class="number">4</span>  <span class="number">0.151650</span>  <span class="number">0.187735</span></span><br><span class="line">     Yes        <span class="number">15</span>  <span class="number">0.174783</span>  <span class="number">0.263480</span></span><br><span class="line">Sat  No         <span class="number">45</span>  <span class="number">0.158048</span>  <span class="number">0.291990</span></span><br><span class="line">     Yes        <span class="number">42</span>  <span class="number">0.147906</span>  <span class="number">0.325733</span></span><br><span class="line">Sun  No         <span class="number">57</span>  <span class="number">0.160113</span>  <span class="number">0.252672</span></span><br><span class="line">     Yes        <span class="number">19</span>  <span class="number">0.187250</span>  <span class="number">0.710345</span></span><br><span class="line">Thur No         <span class="number">45</span>  <span class="number">0.160298</span>  <span class="number">0.266312</span></span><br><span class="line">     Yes        <span class="number">17</span>  <span class="number">0.163863</span>  <span class="number">0.241255</span></span><br></pre></td></tr></table></figure>

<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">&#x27;Durchschnitt&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>),(<span class="string">&#x27;Abweichung&#x27;</span>, np.var)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: grouped[<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;total_bill&#x27;</span>].agg(ftuples)</span><br><span class="line">Out[<span class="number">70</span>]: </span><br><span class="line">                 tip_pct              total_bill            </span><br><span class="line">            Durchschnitt Abweichung Durchschnitt  Abweichung</span><br><span class="line">day  smoker                                                 </span><br><span class="line">Fri  No         <span class="number">0.151650</span>   <span class="number">0.000791</span>    <span class="number">18.420000</span>   <span class="number">25.596333</span></span><br><span class="line">     Yes        <span class="number">0.174783</span>   <span class="number">0.002631</span>    <span class="number">16.813333</span>   <span class="number">82.562438</span></span><br><span class="line">Sat  No         <span class="number">0.158048</span>   <span class="number">0.001581</span>    <span class="number">19.661778</span>   <span class="number">79.908965</span></span><br><span class="line">     Yes        <span class="number">0.147906</span>   <span class="number">0.003767</span>    <span class="number">21.276667</span>  <span class="number">101.387535</span></span><br><span class="line">Sun  No         <span class="number">0.160113</span>   <span class="number">0.001793</span>    <span class="number">20.506667</span>   <span class="number">66.099980</span></span><br><span class="line">     Yes        <span class="number">0.187250</span>   <span class="number">0.023757</span>    <span class="number">24.120000</span>  <span class="number">109.046044</span></span><br><span class="line">Thur No         <span class="number">0.160298</span>   <span class="number">0.001503</span>    <span class="number">17.113111</span>   <span class="number">59.625081</span></span><br><span class="line">     Yes        <span class="number">0.163863</span>   <span class="number">0.001551</span>    <span class="number">19.190588</span>   <span class="number">69.808518</span></span><br></pre></td></tr></table></figure>

<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向agg传入一个从列名映射到函数的字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">&#x27;tip&#x27;</span> : np.<span class="built_in">max</span>, <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">71</span>]: </span><br><span class="line">               tip  size</span><br><span class="line">day  smoker             </span><br><span class="line">Fri  No       <span class="number">3.50</span>     <span class="number">9</span></span><br><span class="line">     Yes      <span class="number">4.73</span>    <span class="number">31</span></span><br><span class="line">Sat  No       <span class="number">9.00</span>   <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">10.00</span>   <span class="number">104</span></span><br><span class="line">Sun  No       <span class="number">6.00</span>   <span class="number">167</span></span><br><span class="line">     Yes      <span class="number">6.50</span>    <span class="number">49</span></span><br><span class="line">Thur No       <span class="number">6.70</span>   <span class="number">112</span></span><br><span class="line">     Yes      <span class="number">5.00</span>    <span class="number">40</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: grouped.agg(&#123;<span class="string">&#x27;tip_pct&#x27;</span> : [<span class="string">&#x27;min&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>],</span><br><span class="line">   ....:              <span class="string">&#x27;size&#x27;</span> : <span class="string">&#x27;sum&#x27;</span>&#125;)</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">              tip_pct                               size</span><br><span class="line">                  <span class="built_in">min</span>       <span class="built_in">max</span>      mean       std  <span class="built_in">sum</span></span><br><span class="line">day  smoker                                             </span><br><span class="line">Fri  No      <span class="number">0.120385</span>  <span class="number">0.187735</span>  <span class="number">0.151650</span>  <span class="number">0.028123</span>    <span class="number">9</span></span><br><span class="line">     Yes     <span class="number">0.103555</span>  <span class="number">0.263480</span>  <span class="number">0.174783</span>  <span class="number">0.051293</span>   <span class="number">31</span></span><br><span class="line">Sat  No      <span class="number">0.056797</span>  <span class="number">0.291990</span>  <span class="number">0.158048</span>  <span class="number">0.039767</span>  <span class="number">115</span></span><br><span class="line">     Yes     <span class="number">0.035638</span>  <span class="number">0.325733</span>  <span class="number">0.147906</span>  <span class="number">0.061375</span>  <span class="number">104</span></span><br><span class="line">Sun  No      <span class="number">0.059447</span>  <span class="number">0.252672</span>  <span class="number">0.160113</span>  <span class="number">0.042347</span>  <span class="number">167</span></span><br><span class="line">     Yes     <span class="number">0.065660</span>  <span class="number">0.710345</span>  <span class="number">0.187250</span>  <span class="number">0.154134</span>   <span class="number">49</span></span><br><span class="line">Thur No      <span class="number">0.072961</span>  <span class="number">0.266312</span>  <span class="number">0.160298</span>  <span class="number">0.038774</span>  <span class="number">112</span></span><br><span class="line">     Yes     <span class="number">0.090014</span>  <span class="number">0.241255</span>  <span class="number">0.163863</span>  <span class="number">0.039389</span>   <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>只有将多个函数应用到至少一列时，DataFrame才会拥有层次化的列。</p>
<h2 id="以“没有行索引”的形式返回聚合数据"><a href="#以“没有行索引”的形式返回聚合数据" class="headerlink" title="以“没有行索引”的形式返回聚合数据"></a>以“没有行索引”的形式返回聚合数据</h2><p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向groupby传入as_index=False以禁用该功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">73</span>]: tips.groupby([<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], as_index=<span class="literal">False</span>).mean()</span><br><span class="line">Out[<span class="number">73</span>]: </span><br><span class="line">    day smoker  total_bill       tip      size   tip_pct</span><br><span class="line"><span class="number">0</span>   Fri     No   <span class="number">18.420000</span>  <span class="number">2.812500</span>  <span class="number">2.250000</span>  <span class="number">0.151650</span></span><br><span class="line"><span class="number">1</span>   Fri    Yes   <span class="number">16.813333</span>  <span class="number">2.714000</span>  <span class="number">2.066667</span>  <span class="number">0.174783</span></span><br><span class="line"><span class="number">2</span>   Sat     No   <span class="number">19.661778</span>  <span class="number">3.102889</span>  <span class="number">2.555556</span>  <span class="number">0.158048</span></span><br><span class="line"><span class="number">3</span>   Sat    Yes   <span class="number">21.276667</span>  <span class="number">2.875476</span>  <span class="number">2.476190</span>  <span class="number">0.147906</span></span><br><span class="line"><span class="number">4</span>   Sun     No   <span class="number">20.506667</span>  <span class="number">3.167895</span>  <span class="number">2.929825</span>  <span class="number">0.160113</span></span><br><span class="line"><span class="number">5</span>   Sun    Yes   <span class="number">24.120000</span>  <span class="number">3.516842</span>  <span class="number">2.578947</span>  <span class="number">0.187250</span></span><br><span class="line"><span class="number">6</span>  Thur     No   <span class="number">17.113111</span>  <span class="number">2.673778</span>  <span class="number">2.488889</span>  <span class="number">0.160298</span></span><br><span class="line"><span class="number">7</span>  Thur    Yes   <span class="number">19.190588</span>  <span class="number">3.030000</span>  <span class="number">2.352941</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure>

<p>当然，对结果调用reset_index也能得到这种形式的结果。使用as_index=False方法可以避免一些不必要的计算。</p>
<h1 id="10-3-apply：一般性的“拆分－应用－合并”"><a href="#10-3-apply：一般性的“拆分－应用－合并”" class="headerlink" title="10.3 apply：一般性的“拆分－应用－合并”"></a>10.3 apply：一般性的“拆分－应用－合并”</h1><p>最通用的GroupBy方法是apply，本节剩余部分将重点讲解它。如图10-2所示，apply会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。</p>
<p><img src="/post/b0f8d937/7178691-7e8bb217f599b4ae.png" alt="图10-2 分组聚合示例"></p>
<p>回到之前那个小费数据集，假设你想要根据分组选出最高的5个tip_pct值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">df, n=<span class="number">5</span>, column=<span class="string">&#x27;tip_pct&#x27;</span></span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> df.sort_values(by=column)[-n:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: top(tips, n=<span class="number">6</span>)</span><br><span class="line">Out[<span class="number">75</span>]: </span><br><span class="line">     total_bill   tip smoker  day    time  size   tip_pct</span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes  Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes  Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No  Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes  Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes  Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>

<p>现在，如果对smoker分组并用该函数调用apply，就会得到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>).apply(top)</span><br><span class="line">Out[<span class="number">76</span>]: </span><br><span class="line">            total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker                                                           </span><br><span class="line">No     <span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line">       <span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line">       <span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line">       <span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line">       <span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line">Yes    <span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line">       <span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line">       <span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line">       <span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line">       <span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>

<p>这里发生了什么？top函数在DataFrame的各个片段上调用，然后结果由pandas.concat组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原DataFrame。</p>
<p>如果传给apply的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">77</span>]: tips.groupby([<span class="string">&#x27;smoker&#x27;</span>, <span class="string">&#x27;day&#x27;</span>]).apply(top, n=<span class="number">1</span>, column=<span class="string">&#x27;total_bill&#x27;</span>)</span><br><span class="line">Out[<span class="number">77</span>]: </span><br><span class="line">                 total_bill    tip smoker   day    time  size   tip_pct</span><br><span class="line">smoker day                                                             </span><br><span class="line">No     Fri  <span class="number">94</span>        <span class="number">22.75</span>   <span class="number">3.25</span>     No   Fri  Dinner     <span class="number">2</span>  <span class="number">0.142857</span></span><br><span class="line">       Sat  <span class="number">212</span>       <span class="number">48.33</span>   <span class="number">9.00</span>     No   Sat  Dinner     <span class="number">4</span>  <span class="number">0.186220</span></span><br><span class="line">       Sun  <span class="number">156</span>       <span class="number">48.17</span>   <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">6</span>  <span class="number">0.103799</span></span><br><span class="line">       Thur <span class="number">142</span>       <span class="number">41.19</span>   <span class="number">5.00</span>     No  Thur   Lunch     <span class="number">5</span>  <span class="number">0.121389</span></span><br><span class="line">Yes    Fri  <span class="number">95</span>        <span class="number">40.17</span>   <span class="number">4.73</span>    Yes   Fri  Dinner     <span class="number">4</span>  <span class="number">0.117750</span></span><br><span class="line">       Sat  <span class="number">170</span>       <span class="number">50.81</span>  <span class="number">10.00</span>    Yes   Sat  Dinner     <span class="number">3</span>  <span class="number">0.196812</span></span><br><span class="line">       Sun  <span class="number">182</span>       <span class="number">45.35</span>   <span class="number">3.50</span>    Yes   Sun  Dinner     <span class="number">3</span>  <span class="number">0.077178</span></span><br><span class="line">       Thur <span class="number">197</span>       <span class="number">43.11</span>   <span class="number">5.00</span>    Yes  Thur   Lunch     <span class="number">4</span>  <span class="number">0.115982</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>笔记：除这些基本用法之外，能否充分发挥apply的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个pandas对象或标量值即可。本章后续部分的示例主要用于讲解如何利用groupby解决各种各样的问题。</p>
</blockquote>
<p>可能你已经想起来了，之前我在GroupBy对象上调用过describe：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">78</span>]: result = tips.groupby(<span class="string">&#x27;smoker&#x27;</span>)[<span class="string">&#x27;tip_pct&#x27;</span>].describe()</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: result</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">        count      mean       std       <span class="built_in">min</span>       <span class="number">25</span>%       <span class="number">50</span>%       <span class="number">75</span>%  \</span><br><span class="line">smoker                                                                      </span><br><span class="line">No      <span class="number">151.0</span>  <span class="number">0.159328</span>  <span class="number">0.039910</span>  <span class="number">0.056797</span>  <span class="number">0.136906</span>  <span class="number">0.155625</span>  <span class="number">0.185014</span>   </span><br><span class="line">Yes      <span class="number">93.0</span>  <span class="number">0.163196</span>  <span class="number">0.085119</span>  <span class="number">0.035638</span>  <span class="number">0.106771</span>  <span class="number">0.153846</span>  <span class="number">0.195059</span>   </span><br><span class="line">             <span class="built_in">max</span>  </span><br><span class="line">smoker</span><br><span class="line"></span><br><span class="line">No      <span class="number">0.291990</span>  </span><br><span class="line">Yes     <span class="number">0.710345</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: result.unstack(<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">80</span>]: </span><br><span class="line">       smoker</span><br><span class="line">count  No        <span class="number">151.000000</span></span><br><span class="line">       Yes        <span class="number">93.000000</span></span><br><span class="line">mean   No          <span class="number">0.159328</span></span><br><span class="line">       Yes         <span class="number">0.163196</span></span><br><span class="line">std    No          <span class="number">0.039910</span></span><br><span class="line">       Yes         <span class="number">0.085119</span></span><br><span class="line"><span class="built_in">min</span>    No          <span class="number">0.056797</span></span><br><span class="line">       Yes         <span class="number">0.035638</span></span><br><span class="line"><span class="number">25</span>%    No          <span class="number">0.136906</span></span><br><span class="line">       Yes         <span class="number">0.106771</span></span><br><span class="line"><span class="number">50</span>%    No          <span class="number">0.155625</span></span><br><span class="line">       Yes         <span class="number">0.153846</span></span><br><span class="line"><span class="number">75</span>%    No          <span class="number">0.185014</span></span><br><span class="line">       Yes         <span class="number">0.195059</span></span><br><span class="line"><span class="built_in">max</span>    No          <span class="number">0.291990</span></span><br><span class="line">       Yes         <span class="number">0.710345</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>在GroupBy中，当你调用诸如describe之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x.describe()</span><br><span class="line">grouped.apply(f)</span><br></pre></td></tr></table></figure>

<h2 id="禁止分组键"><a href="#禁止分组键" class="headerlink" title="禁止分组键"></a>禁止分组键</h2><p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将group_keys=False传入groupby即可禁止该效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">81</span>]: tips.groupby(<span class="string">&#x27;smoker&#x27;</span>, group_keys=<span class="literal">False</span>).apply(top)</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">     total_bill   tip smoker   day    time  size   tip_pct</span><br><span class="line"><span class="number">88</span>        <span class="number">24.71</span>  <span class="number">5.85</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.236746</span></span><br><span class="line"><span class="number">185</span>       <span class="number">20.69</span>  <span class="number">5.00</span>     No   Sun  Dinner     <span class="number">5</span>  <span class="number">0.241663</span></span><br><span class="line"><span class="number">51</span>        <span class="number">10.29</span>  <span class="number">2.60</span>     No   Sun  Dinner     <span class="number">2</span>  <span class="number">0.252672</span></span><br><span class="line"><span class="number">149</span>        <span class="number">7.51</span>  <span class="number">2.00</span>     No  Thur   Lunch     <span class="number">2</span>  <span class="number">0.266312</span></span><br><span class="line"><span class="number">232</span>       <span class="number">11.61</span>  <span class="number">3.39</span>     No   Sat  Dinner     <span class="number">2</span>  <span class="number">0.291990</span></span><br><span class="line"><span class="number">109</span>       <span class="number">14.31</span>  <span class="number">4.00</span>    Yes   Sat  Dinner     <span class="number">2</span>  <span class="number">0.279525</span></span><br><span class="line"><span class="number">183</span>       <span class="number">23.17</span>  <span class="number">6.50</span>    Yes   Sun  Dinner     <span class="number">4</span>  <span class="number">0.280535</span></span><br><span class="line"><span class="number">67</span>         <span class="number">3.07</span>  <span class="number">1.00</span>    Yes   Sat  Dinner     <span class="number">1</span>  <span class="number">0.325733</span></span><br><span class="line"><span class="number">178</span>        <span class="number">9.60</span>  <span class="number">4.00</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.416667</span></span><br><span class="line"><span class="number">172</span>        <span class="number">7.25</span>  <span class="number">5.15</span>    Yes   Sun  Dinner     <span class="number">2</span>  <span class="number">0.710345</span></span><br></pre></td></tr></table></figure>

<h2 id="分位数和桶分析"><a href="#分位数和桶分析" class="headerlink" title="分位数和桶分析"></a>分位数和桶分析</h2><p>我曾在第8章中讲过，pandas有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如cut和qcut）。将这些函数跟groupby结合起来，就能非常轻松地实现对数据集的桶（bucket）或分位数（quantile）分析了。以下面这个简单的随机数据集为例，我们利用cut将其装入长度相等的桶中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">82</span>]: frame = pd.DataFrame(&#123;<span class="string">&#x27;data1&#x27;</span>: np.random.randn(<span class="number">1000</span>),</span><br><span class="line">   ....:                       <span class="string">&#x27;data2&#x27;</span>: np.random.randn(<span class="number">1000</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">83</span>]: quartiles = pd.cut(frame.data1, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: quartiles[:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">84</span>]: </span><br><span class="line"><span class="number">0</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">1</span>    (-<span class="number">2.956</span>, -<span class="number">1.23</span>]</span><br><span class="line"><span class="number">2</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">3</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">4</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">5</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">6</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">7</span>     (-<span class="number">1.23</span>, <span class="number">0.489</span>]</span><br><span class="line"><span class="number">8</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line"><span class="number">9</span>     (<span class="number">0.489</span>, <span class="number">2.208</span>]</span><br><span class="line">Name: data1, dtype: category</span><br><span class="line">Categories (<span class="number">4</span>, interval[float64]): [(-<span class="number">2.956</span>, -<span class="number">1.23</span>] &lt; (-<span class="number">1.23</span>, <span class="number">0.489</span>] &lt; (<span class="number">0.489</span>, <span class="number">2.</span></span><br><span class="line"><span class="number">208</span>] &lt; (<span class="number">2.208</span>, <span class="number">3.928</span>]]</span><br></pre></td></tr></table></figure>

<p>由cut返回的Categorical对象可直接传递到groupby。因此，我们可以像下面这样对data2列做一些统计计算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: <span class="keyword">def</span> <span class="title function_">get_stats</span>(<span class="params">group</span>):</span><br><span class="line">   ....:     <span class="keyword">return</span> &#123;<span class="string">&#x27;min&#x27;</span>: group.<span class="built_in">min</span>(), <span class="string">&#x27;max&#x27;</span>: group.<span class="built_in">max</span>(),</span><br><span class="line">   ....:             <span class="string">&#x27;count&#x27;</span>: group.count(), <span class="string">&#x27;mean&#x27;</span>: group.mean()&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: grouped = frame.data2.groupby(quartiles)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">                 count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                               </span><br><span class="line">(-<span class="number">2.956</span>, -<span class="number">1.23</span>]   <span class="number">95.0</span>  <span class="number">1.670835</span> -<span class="number">0.039521</span> -<span class="number">3.399312</span></span><br><span class="line">(-<span class="number">1.23</span>, <span class="number">0.489</span>]   <span class="number">598.0</span>  <span class="number">3.260383</span> -<span class="number">0.002051</span> -<span class="number">2.989741</span></span><br><span class="line">(<span class="number">0.489</span>, <span class="number">2.208</span>]   <span class="number">297.0</span>  <span class="number">2.954439</span>  <span class="number">0.081822</span> -<span class="number">3.745356</span></span><br><span class="line">(<span class="number">2.208</span>, <span class="number">3.928</span>]    <span class="number">10.0</span>  <span class="number">1.765640</span>  <span class="number">0.024750</span> -<span class="number">1.929776</span></span><br></pre></td></tr></table></figure>

<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用qcut即可。传入labels=False即可只获取分位数的编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Return quantile numbers</span></span><br><span class="line">In [<span class="number">88</span>]: grouping = pd.qcut(frame.data1, <span class="number">10</span>, labels=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: grouped = frame.data2.groupby(grouping)</span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: grouped.apply(get_stats).unstack()</span><br><span class="line">Out[<span class="number">90</span>]: </span><br><span class="line">       count       <span class="built_in">max</span>      mean       <span class="built_in">min</span></span><br><span class="line">data1                                     </span><br><span class="line"><span class="number">0</span>      <span class="number">100.0</span>  <span class="number">1.670835</span> -<span class="number">0.049902</span> -<span class="number">3.399312</span></span><br><span class="line"><span class="number">1</span>      <span class="number">100.0</span>  <span class="number">2.628441</span>  <span class="number">0.030989</span> -<span class="number">1.950098</span></span><br><span class="line"><span class="number">2</span>      <span class="number">100.0</span>  <span class="number">2.527939</span> -<span class="number">0.067179</span> -<span class="number">2.925113</span></span><br><span class="line"><span class="number">3</span>      <span class="number">100.0</span>  <span class="number">3.260383</span>  <span class="number">0.065713</span> -<span class="number">2.315555</span></span><br><span class="line"><span class="number">4</span>      <span class="number">100.0</span>  <span class="number">2.074345</span> -<span class="number">0.111653</span> -<span class="number">2.047939</span></span><br><span class="line"><span class="number">5</span>      <span class="number">100.0</span>  <span class="number">2.184810</span>  <span class="number">0.052130</span> -<span class="number">2.989741</span></span><br><span class="line"><span class="number">6</span>      <span class="number">100.0</span>  <span class="number">2.458842</span> -<span class="number">0.021489</span> -<span class="number">2.223506</span></span><br><span class="line"><span class="number">7</span>      <span class="number">100.0</span>  <span class="number">2.954439</span> -<span class="number">0.026459</span> -<span class="number">3.056990</span></span><br><span class="line"><span class="number">8</span>      <span class="number">100.0</span>  <span class="number">2.735527</span>  <span class="number">0.103406</span> -<span class="number">3.745356</span></span><br><span class="line"><span class="number">9</span>      <span class="number">100.0</span>  <span class="number">2.377020</span>  <span class="number">0.220122</span> -<span class="number">2.064111</span></span><br></pre></td></tr></table></figure>

<p>我们会在第12章详细讲解pandas的Categorical类型。</p>
<h2 id="示例：用特定于分组的值填充缺失值"><a href="#示例：用特定于分组的值填充缺失值" class="headerlink" title="示例：用特定于分组的值填充缺失值"></a>示例：用特定于分组的值填充缺失值</h2><p>对于缺失数据的清理工作，有时你会用dropna将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充NA值。这时就得使用fillna这个工具了。在下面这个例子中，我用平均值去填充NA值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">91</span>]: s = pd.Series(np.random.randn(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: s[::<span class="number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: s</span><br><span class="line">Out[<span class="number">93</span>]: </span><br><span class="line"><span class="number">0</span>         NaN</span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>         NaN</span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>         NaN</span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: s.fillna(s.mean())</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">0</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">1</span>   -<span class="number">0.125921</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.884475</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">0.261035</span></span><br><span class="line"><span class="number">5</span>    <span class="number">0.227290</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用apply和一个能够对各数据块调用fillna的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">95</span>]: states = [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Florida&#x27;</span>,</span><br><span class="line">   ....:           <span class="string">&#x27;Oregon&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: group_key = [<span class="string">&#x27;East&#x27;</span>] * <span class="number">4</span> + [<span class="string">&#x27;West&#x27;</span>] * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: data = pd.Series(np.random.randn(<span class="number">8</span>), index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: data</span><br><span class="line">Out[<span class="number">98</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.365757</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.981994</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.613716</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>[‘East’] * 4产生了一个列表，包括了[‘East’]中元素的四个拷贝。将这些列表串联起来。</p>
<p>将一些值设为缺失：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">99</span>]: data[[<span class="string">&#x27;Vermont&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Idaho&#x27;</span>]] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: data</span><br><span class="line">Out[<span class="number">100</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont            NaN</span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada             NaN</span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho              NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: data.groupby(group_key).mean()</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">East   -<span class="number">0.535707</span></span><br><span class="line">West    <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>我们可以用分组平均值去填充NA值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: fill_mean = <span class="keyword">lambda</span> g: g.fillna(g.mean())</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: data.groupby(group_key).apply(fill_mean)</span><br><span class="line">Out[<span class="number">103</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont      -<span class="number">0.535707</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada        <span class="number">0.717926</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho         <span class="number">0.717926</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个name属性，所以我们可以拿来用一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">104</span>]: fill_values = &#123;<span class="string">&#x27;East&#x27;</span>: <span class="number">0.5</span>, <span class="string">&#x27;West&#x27;</span>: -<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: fill_func = <span class="keyword">lambda</span> g: g.fillna(fill_values[g.name])</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: data.groupby(group_key).apply(fill_func)</span><br><span class="line">Out[<span class="number">106</span>]: </span><br><span class="line">Ohio          <span class="number">0.922264</span></span><br><span class="line">New York     -<span class="number">2.153545</span></span><br><span class="line">Vermont       <span class="number">0.500000</span></span><br><span class="line">Florida      -<span class="number">0.375842</span></span><br><span class="line">Oregon        <span class="number">0.329939</span></span><br><span class="line">Nevada       -<span class="number">1.000000</span></span><br><span class="line">California    <span class="number">1.105913</span></span><br><span class="line">Idaho        -<span class="number">1.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="示例：随机采样和排列"><a href="#示例：随机采样和排列" class="headerlink" title="示例：随机采样和排列"></a>示例：随机采样和排列</h2><p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（Monte Carlo simulation）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对Series使用sample方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hearts, Spades, Clubs, Diamonds</span></span><br><span class="line">suits = [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">card_val = (<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)) + [<span class="number">10</span>] * <span class="number">3</span>) * <span class="number">4</span></span><br><span class="line">base_names = [<span class="string">&#x27;A&#x27;</span>] + <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)) + [<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>]</span><br><span class="line">cards = []</span><br><span class="line"><span class="keyword">for</span> suit <span class="keyword">in</span> [<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]:</span><br><span class="line">    cards.extend(<span class="built_in">str</span>(num) + suit <span class="keyword">for</span> num <span class="keyword">in</span> base_names)</span><br><span class="line"></span><br><span class="line">deck = pd.Series(card_val, index=cards)</span><br></pre></td></tr></table></figure>

<p>现在我有了一个长度为52的Series，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: deck[:<span class="number">13</span>]</span><br><span class="line">Out[<span class="number">108</span>]: </span><br><span class="line">AH      <span class="number">1</span></span><br><span class="line">2H      <span class="number">2</span></span><br><span class="line">3H      <span class="number">3</span></span><br><span class="line">4H      <span class="number">4</span></span><br><span class="line">5H      <span class="number">5</span></span><br><span class="line">6H      <span class="number">6</span></span><br><span class="line">7H      <span class="number">7</span></span><br><span class="line">8H      <span class="number">8</span></span><br><span class="line">9H      <span class="number">9</span></span><br><span class="line">10H    <span class="number">10</span></span><br><span class="line">JH     <span class="number">10</span></span><br><span class="line">KH     <span class="number">10</span></span><br><span class="line">QH     <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">109</span>]: <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">deck, n=<span class="number">5</span></span>):</span><br><span class="line">   .....:     <span class="keyword">return</span> deck.sample(n)</span><br><span class="line"></span><br><span class="line">In [<span class="number">110</span>]: draw(deck)</span><br><span class="line">Out[<span class="number">110</span>]: </span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">8C     <span class="number">8</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">2C     <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用apply：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">111</span>]: get_suit = <span class="keyword">lambda</span> card: card[-<span class="number">1</span>] <span class="comment"># last letter is suit</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">112</span>]: deck.groupby(get_suit).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">C  2C     <span class="number">2</span></span><br><span class="line">   3C     <span class="number">3</span></span><br><span class="line">D  KD    <span class="number">10</span></span><br><span class="line">   8D     <span class="number">8</span></span><br><span class="line">H  KH    <span class="number">10</span></span><br><span class="line">   3H     <span class="number">3</span></span><br><span class="line">S  2S     <span class="number">2</span></span><br><span class="line">   4S     <span class="number">4</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>或者，也可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: deck.groupby(get_suit, group_keys=<span class="literal">False</span>).apply(draw, n=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">KC    <span class="number">10</span></span><br><span class="line">JC    <span class="number">10</span></span><br><span class="line">AD     <span class="number">1</span></span><br><span class="line">5D     <span class="number">5</span></span><br><span class="line">5H     <span class="number">5</span></span><br><span class="line">6H     <span class="number">6</span></span><br><span class="line">7S     <span class="number">7</span></span><br><span class="line">KS    <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<h2 id="示例：分组加权平均数和相关系数"><a href="#示例：分组加权平均数和相关系数" class="headerlink" title="示例：分组加权平均数和相关系数"></a>示例：分组加权平均数和相关系数</h2><p>根据groupby的“拆分－应用－合并”范式，可以进行DataFrame的列与列之间或两个Series之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">114</span>]: df = pd.DataFrame(&#123;<span class="string">&#x27;category&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">   .....:                                 <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">   .....:                    <span class="string">&#x27;data&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">   .....:                    <span class="string">&#x27;weights&#x27;</span>: np.random.rand(<span class="number">8</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">115</span>]: df</span><br><span class="line">Out[<span class="number">115</span>]: </span><br><span class="line">  category      data   weights</span><br><span class="line"><span class="number">0</span>        a  <span class="number">1.561587</span>  <span class="number">0.957515</span></span><br><span class="line"><span class="number">1</span>        a  <span class="number">1.219984</span>  <span class="number">0.347267</span></span><br><span class="line"><span class="number">2</span>        a -<span class="number">0.482239</span>  <span class="number">0.581362</span></span><br><span class="line"><span class="number">3</span>        a  <span class="number">0.315667</span>  <span class="number">0.217091</span></span><br><span class="line"><span class="number">4</span>        b -<span class="number">0.047852</span>  <span class="number">0.894406</span></span><br><span class="line"><span class="number">5</span>        b -<span class="number">0.454145</span>  <span class="number">0.918564</span></span><br><span class="line"><span class="number">6</span>        b -<span class="number">0.556774</span>  <span class="number">0.277825</span></span><br><span class="line"><span class="number">7</span>        b  <span class="number">0.253321</span>  <span class="number">0.955905</span></span><br></pre></td></tr></table></figure>

<p>然后可以利用category计算分组加权平均数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">116</span>]: grouped = df.groupby(<span class="string">&#x27;category&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: get_wavg = <span class="keyword">lambda</span> g: np.average(g[<span class="string">&#x27;data&#x27;</span>], weights=g[<span class="string">&#x27;weights&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">118</span>]: grouped.apply(get_wavg)</span><br><span class="line">Out[<span class="number">118</span>]:</span><br><span class="line">category</span><br><span class="line">a    <span class="number">0.811643</span></span><br><span class="line">b   -<span class="number">0.122262</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">119</span>]: close_px = pd.read_csv(<span class="string">&#x27;examples/stock_px_2.csv&#x27;</span>, parse_dates=<span class="literal">True</span>,</span><br><span class="line">   .....:                        index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">120</span>]: close_px.info()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;</span><br><span class="line">DatetimeIndex: <span class="number">2214</span> entries, <span class="number">2003</span>-01-02 to <span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span></span><br><span class="line">Data columns (total <span class="number">4</span> columns):</span><br><span class="line">AAPL    <span class="number">2214</span> non-null float64</span><br><span class="line">MSFT    <span class="number">2214</span> non-null float64</span><br><span class="line">XOM     <span class="number">2214</span> non-null float64</span><br><span class="line">SPX     <span class="number">2214</span> non-null float64</span><br><span class="line">dtypes: float64(<span class="number">4</span>)</span><br><span class="line">memory usage: <span class="number">86.5</span> KB</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: close_px[-<span class="number">4</span>:]</span><br><span class="line">Out[<span class="number">121</span>]: </span><br><span class="line">              AAPL   MSFT    XOM      SPX</span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">11</span>  <span class="number">400.29</span>  <span class="number">27.00</span>  <span class="number">76.27</span>  <span class="number">1195.54</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">12</span>  <span class="number">402.19</span>  <span class="number">26.96</span>  <span class="number">77.16</span>  <span class="number">1207.25</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">13</span>  <span class="number">408.43</span>  <span class="number">27.18</span>  <span class="number">76.37</span>  <span class="number">1203.66</span></span><br><span class="line"><span class="number">2011</span>-<span class="number">10</span>-<span class="number">14</span>  <span class="number">422.00</span>  <span class="number">27.27</span>  <span class="number">78.11</span>  <span class="number">1224.58</span></span><br></pre></td></tr></table></figure>

<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的DataFrame。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">122</span>]: spx_corr = <span class="keyword">lambda</span> x: x.corrwith(x[<span class="string">&#x27;SPX&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>接下来，我们使用pct_change计算close_px的百分比变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">123</span>]: rets = close_px.pct_change().dropna()</span><br></pre></td></tr></table></figure>

<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个datetime标签的year属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">124</span>]: get_year = <span class="keyword">lambda</span> x: x.year</span><br><span class="line"></span><br><span class="line">In [<span class="number">125</span>]: by_year = rets.groupby(get_year)</span><br><span class="line"></span><br><span class="line">In [<span class="number">126</span>]: by_year.apply(spx_corr)</span><br><span class="line">Out[<span class="number">126</span>]: </span><br><span class="line">          AAPL      MSFT       XOM  SPX</span><br><span class="line"><span class="number">2003</span>  <span class="number">0.541124</span>  <span class="number">0.745174</span>  <span class="number">0.661265</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">0.374283</span>  <span class="number">0.588531</span>  <span class="number">0.557742</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">0.467540</span>  <span class="number">0.562374</span>  <span class="number">0.631010</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">0.428267</span>  <span class="number">0.406126</span>  <span class="number">0.518514</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">0.508118</span>  <span class="number">0.658770</span>  <span class="number">0.786264</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.681434</span>  <span class="number">0.804626</span>  <span class="number">0.828303</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.707103</span>  <span class="number">0.654902</span>  <span class="number">0.797921</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">0.710105</span>  <span class="number">0.730118</span>  <span class="number">0.839057</span>  <span class="number">1.0</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.691931</span>  <span class="number">0.800996</span>  <span class="number">0.859975</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>当然，你还可以计算列与列之间的相关系数。这里，我们计算Apple和Microsoft的年相关系数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">127</span>]: by_year.apply(<span class="keyword">lambda</span> g: g[<span class="string">&#x27;AAPL&#x27;</span>].corr(g[<span class="string">&#x27;MSFT&#x27;</span>]))</span><br><span class="line">Out[<span class="number">127</span>]: </span><br><span class="line"><span class="number">2003</span>    <span class="number">0.480868</span></span><br><span class="line"><span class="number">2004</span>    <span class="number">0.259024</span></span><br><span class="line"><span class="number">2005</span>    <span class="number">0.300093</span></span><br><span class="line"><span class="number">2006</span>    <span class="number">0.161735</span></span><br><span class="line"><span class="number">2007</span>    <span class="number">0.417738</span></span><br><span class="line"><span class="number">2008</span>    <span class="number">0.611901</span></span><br><span class="line"><span class="number">2009</span>    <span class="number">0.432738</span></span><br><span class="line"><span class="number">2010</span>    <span class="number">0.571946</span></span><br><span class="line"><span class="number">2011</span>    <span class="number">0.581987</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<h2 id="示例：组级别的线性回归"><a href="#示例：组级别的线性回归" class="headerlink" title="示例：组级别的线性回归"></a>示例：组级别的线性回归</h2><p>顺着上一个例子继续，你可以用groupby执行更为复杂的分组统计分析，只要函数返回的是pandas对象或标量值即可。例如，我可以定义下面这个regress函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regress</span>(<span class="params">data, yvar, xvars</span>):</span><br><span class="line">    Y = data[yvar]</span><br><span class="line">    X = data[xvars]</span><br><span class="line">    X[<span class="string">&#x27;intercept&#x27;</span>] = <span class="number">1.</span></span><br><span class="line">    result = sm.OLS(Y, X).fit()</span><br><span class="line">    <span class="keyword">return</span> result.params</span><br></pre></td></tr></table></figure>

<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">129</span>]: by_year.apply(regress, <span class="string">&#x27;AAPL&#x27;</span>, [<span class="string">&#x27;SPX&#x27;</span>])</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">           SPX  intercept</span><br><span class="line"><span class="number">2003</span>  <span class="number">1.195406</span>   <span class="number">0.000710</span></span><br><span class="line"><span class="number">2004</span>  <span class="number">1.363463</span>   <span class="number">0.004201</span></span><br><span class="line"><span class="number">2005</span>  <span class="number">1.766415</span>   <span class="number">0.003246</span></span><br><span class="line"><span class="number">2006</span>  <span class="number">1.645496</span>   <span class="number">0.000080</span></span><br><span class="line"><span class="number">2007</span>  <span class="number">1.198761</span>   <span class="number">0.003438</span></span><br><span class="line"><span class="number">2008</span>  <span class="number">0.968016</span>  -<span class="number">0.001110</span></span><br><span class="line"><span class="number">2009</span>  <span class="number">0.879103</span>   <span class="number">0.002954</span></span><br><span class="line"><span class="number">2010</span>  <span class="number">1.052608</span>   <span class="number">0.001261</span></span><br><span class="line"><span class="number">2011</span>  <span class="number">0.806605</span>   <span class="number">0.001514</span></span><br></pre></td></tr></table></figure>

<h1 id="10-4-透视表和交叉表"><a href="#10-4-透视表和交叉表" class="headerlink" title="10.4 透视表和交叉表"></a>10.4 透视表和交叉表</h1><p>透视表（pivot table）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在Python和pandas中，可以通过本章所介绍的groupby功能以及（能够利用层次化索引的）重塑运算制作透视表。DataFrame有一个pivot_table方法，此外还有一个顶级的pandas.pivot_table函数。除能为groupby提供便利之外，pivot_table还可以添加分项小计，也叫做margins。</p>
<p>回到小费数据集，假设我想要根据day和smoker计算分组平均数（pivot_table的默认聚合类型），并将day和smoker放到行上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">130</span>]: tips.pivot_table(index=[<span class="string">&#x27;day&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>])</span><br><span class="line">Out[<span class="number">130</span>]: </span><br><span class="line">                 size       tip   tip_pct  total_bill</span><br><span class="line">day  smoker                                          </span><br><span class="line">Fri  No      <span class="number">2.250000</span>  <span class="number">2.812500</span>  <span class="number">0.151650</span>   <span class="number">18.420000</span></span><br><span class="line">     Yes     <span class="number">2.066667</span>  <span class="number">2.714000</span>  <span class="number">0.174783</span>   <span class="number">16.813333</span></span><br><span class="line">Sat  No      <span class="number">2.555556</span>  <span class="number">3.102889</span>  <span class="number">0.158048</span>   <span class="number">19.661778</span></span><br><span class="line">     Yes     <span class="number">2.476190</span>  <span class="number">2.875476</span>  <span class="number">0.147906</span>   <span class="number">21.276667</span></span><br><span class="line">Sun  No      <span class="number">2.929825</span>  <span class="number">3.167895</span>  <span class="number">0.160113</span>   <span class="number">20.506667</span></span><br><span class="line">     Yes     <span class="number">2.578947</span>  <span class="number">3.516842</span>  <span class="number">0.187250</span>   <span class="number">24.120000</span></span><br><span class="line">Thur No      <span class="number">2.488889</span>  <span class="number">2.673778</span>  <span class="number">0.160298</span>   <span class="number">17.113111</span></span><br><span class="line">     Yes     <span class="number">2.352941</span>  <span class="number">3.030000</span>  <span class="number">0.163863</span>   <span class="number">19.190588</span></span><br></pre></td></tr></table></figure>

<p>可以用groupby直接来做。现在，假设我们只想聚合tip_pct和size，而且想根据time进行分组。我将smoker放到列上，把day放到行上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">131</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>)</span><br><span class="line">Out[<span class="number">131</span>]: </span><br><span class="line">                 size             tip_pct          </span><br><span class="line">smoker             No       Yes        No       Yes</span><br><span class="line">time   day                                         </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">0.159744</span>       NaN</span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span></span><br></pre></td></tr></table></figure>

<p>还可以对这个表作进一步的处理，传入margins=True添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">132</span>]: tips.pivot_table([<span class="string">&#x27;tip_pct&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;day&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;smoker&#x27;</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">                 size                       tip_pct                    </span><br><span class="line">smoker             No       Yes       All        No       Yes       All</span><br><span class="line">time   day                                                             </span><br><span class="line">Dinner Fri   <span class="number">2.000000</span>  <span class="number">2.222222</span>  <span class="number">2.166667</span>  <span class="number">0.139622</span>  <span class="number">0.165347</span>  <span class="number">0.158916</span></span><br><span class="line">       Sat   <span class="number">2.555556</span>  <span class="number">2.476190</span>  <span class="number">2.517241</span>  <span class="number">0.158048</span>  <span class="number">0.147906</span>  <span class="number">0.153152</span></span><br><span class="line">       Sun   <span class="number">2.929825</span>  <span class="number">2.578947</span>  <span class="number">2.842105</span>  <span class="number">0.160113</span>  <span class="number">0.187250</span>  <span class="number">0.166897</span></span><br><span class="line">       Thur  <span class="number">2.000000</span>       NaN  <span class="number">2.000000</span>  <span class="number">0.159744</span>       NaN  <span class="number">0.159744</span></span><br><span class="line">Lunch  Fri   <span class="number">3.000000</span>  <span class="number">1.833333</span>  <span class="number">2.000000</span>  <span class="number">0.187735</span>  <span class="number">0.188937</span>  <span class="number">0.188765</span></span><br><span class="line">       Thur  <span class="number">2.500000</span>  <span class="number">2.352941</span>  <span class="number">2.459016</span>  <span class="number">0.160311</span>  <span class="number">0.163863</span>  <span class="number">0.161301</span></span><br><span class="line">All          <span class="number">2.668874</span>  <span class="number">2.408602</span>  <span class="number">2.569672</span>  <span class="number">0.159328</span>  <span class="number">0.163196</span>  <span class="number">0.160803</span></span><br></pre></td></tr></table></figure>

<p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p>
<p>要使用其他的聚合函数，将其传给aggfunc即可。例如，使用count或len可以得到有关分组大小的交叉表（计数或频率）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">133</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>], columns=<span class="string">&#x27;day&#x27;</span>,</span><br><span class="line">   .....:                  aggfunc=<span class="built_in">len</span>, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">133</span>]: </span><br><span class="line">day             Fri   Sat   Sun  Thur    All</span><br><span class="line">time   smoker                               </span><br><span class="line">Dinner No       <span class="number">3.0</span>  <span class="number">45.0</span>  <span class="number">57.0</span>   <span class="number">1.0</span>  <span class="number">106.0</span></span><br><span class="line">       Yes      <span class="number">9.0</span>  <span class="number">42.0</span>  <span class="number">19.0</span>   NaN   <span class="number">70.0</span></span><br><span class="line">Lunch  No       <span class="number">1.0</span>   NaN   NaN  <span class="number">44.0</span>   <span class="number">45.0</span></span><br><span class="line">       Yes      <span class="number">6.0</span>   NaN   NaN  <span class="number">17.0</span>   <span class="number">23.0</span></span><br><span class="line">All            <span class="number">19.0</span>  <span class="number">87.0</span>  <span class="number">76.0</span>  <span class="number">62.0</span>  <span class="number">244.0</span></span><br></pre></td></tr></table></figure>

<p>如果存在空的组合（也就是NA），你可能会希望设置一个fill_value：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">134</span>]: tips.pivot_table(<span class="string">&#x27;tip_pct&#x27;</span>, index=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;size&#x27;</span>, <span class="string">&#x27;smoker&#x27;</span>],</span><br><span class="line">   .....:                  columns=<span class="string">&#x27;day&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">134</span>]: </span><br><span class="line">day                      Fri       Sat       Sun      Thur</span><br><span class="line">time   size smoker                                        </span><br><span class="line">Dinner <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.137931</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.325733</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.139622</span>  <span class="number">0.162705</span>  <span class="number">0.168859</span>  <span class="number">0.159744</span></span><br><span class="line">            Yes     <span class="number">0.171297</span>  <span class="number">0.148668</span>  <span class="number">0.207893</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.000000</span>  <span class="number">0.154661</span>  <span class="number">0.152663</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.144995</span>  <span class="number">0.152660</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.150096</span>  <span class="number">0.148143</span>  <span class="number">0.000000</span></span><br><span class="line">            Yes     <span class="number">0.117750</span>  <span class="number">0.124515</span>  <span class="number">0.193370</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.206928</span>  <span class="number">0.000000</span></span><br><span class="line">Yes     <span class="number">0.000000</span>  <span class="number">0.106572</span>  <span class="number">0.065660</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="meta">... </span>                     ...       ...       ...       ...</span><br><span class="line">Lunch  <span class="number">1</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.181728</span></span><br><span class="line">            Yes     <span class="number">0.223776</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line">       <span class="number">2</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.166005</span></span><br><span class="line">            Yes     <span class="number">0.181969</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.158843</span></span><br><span class="line">       <span class="number">3</span>    No      <span class="number">0.187735</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.084246</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.204952</span></span><br><span class="line">       <span class="number">4</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.138919</span></span><br><span class="line">            Yes     <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.155410</span></span><br><span class="line">       <span class="number">5</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.121389</span></span><br><span class="line">       <span class="number">6</span>    No      <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span>  <span class="number">0.173706</span></span><br><span class="line">[<span class="number">21</span> rows x <span class="number">4</span> columns]</span><br></pre></td></tr></table></figure>

<p>pivot_table的参数说明请参见表10-2。</p>
<p><img src="/post/b0f8d937/7178691-c9e01844c4803a42.png" alt="表10-2 pivot_table的选项"></p>
<h2 id="交叉表：crosstab"><a href="#交叉表：crosstab" class="headerlink" title="交叉表：crosstab"></a>交叉表：crosstab</h2><p>交叉表（cross-tabulation，简称crosstab）是一种用于计算分组频率的特殊透视表。看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">138</span>]: data</span><br><span class="line">Out[<span class="number">138</span>]:</span><br><span class="line">   Sample Nationality    Handedness</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>         USA  Right-handed</span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>       Japan   Left-handed</span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>         USA  Right-handed</span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>       Japan  Right-handed</span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>       Japan   Left-handed</span><br><span class="line"><span class="number">5</span>       <span class="number">6</span>       Japan  Right-handed</span><br><span class="line"><span class="number">6</span>       <span class="number">7</span>         USA  Right-handed</span><br><span class="line"><span class="number">7</span>       <span class="number">8</span>         USA   Left-handed</span><br><span class="line"><span class="number">8</span>       <span class="number">9</span>       Japan  Right-handed</span><br><span class="line"><span class="number">9</span>      <span class="number">10</span>         USA  Right-handed</span><br></pre></td></tr></table></figure>

<p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用pivot_table实现该功能，但是pandas.crosstab函数会更方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">139</span>]: pd.crosstab(data.Nationality, data.Handedness, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">139</span>]: </span><br><span class="line">Handedness   Left-handed  Right-handed  All</span><br><span class="line">Nationality</span><br><span class="line">Japan                  <span class="number">2</span>             <span class="number">3</span>    <span class="number">5</span></span><br><span class="line">USA                    <span class="number">1</span>             <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">All                    <span class="number">3</span>             <span class="number">7</span>   <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>crosstab的前两个参数可以是数组或Series，或是数组列表。就像小费数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">140</span>]: pd.crosstab([tips.time, tips.day], tips.smoker, margins=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">140</span>]: </span><br><span class="line">smoker        No  Yes  All</span><br><span class="line">time   day                </span><br><span class="line">Dinner Fri     <span class="number">3</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line">       Sat    <span class="number">45</span>   <span class="number">42</span>   <span class="number">87</span></span><br><span class="line">       Sun    <span class="number">57</span>   <span class="number">19</span>   <span class="number">76</span></span><br><span class="line">       Thur    <span class="number">1</span>    <span class="number">0</span>    <span class="number">1</span></span><br><span class="line">Lunch  Fri     <span class="number">1</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">       Thur   <span class="number">44</span>   <span class="number">17</span>   <span class="number">61</span></span><br><span class="line">All          <span class="number">151</span>   <span class="number">93</span>  <span class="number">244</span></span><br></pre></td></tr></table></figure>

<h1 id="10-5-总结"><a href="#10-5-总结" class="headerlink" title="10.5 总结"></a>10.5 总结</h1><p>掌握pandas数据分组工具既有助于数据清理，也有助于建模或统计分析工作。在第14章，我们会看几个例子，对真实数据使用groupby。</p>
<p>在下一章，我们将关注时间序列数据。</p>
<hr>
<p>搬运链接：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version">https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://wh1720848796.github.io">Yincha</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wh1720848796.github.io/post/b0f8d937.html">http://wh1720848796.github.io/post/b0f8d937.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wh1720848796.github.io" target="_blank">饮茶</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/img/HatsuneMiku5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/f03d59e5.html" title="第11章 时间序列"><img class="cover" src="/img/HatsuneMiku5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第11章 时间序列</div></div></a></div><div class="next-post pull-right"><a href="/post/552a3bb8.html" title="第09章 绘图和可视化"><img class="cover" src="/img/HatsuneMiku5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第09章 绘图和可视化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/d93799a0.html" title="第01章 准备工作"><img class="cover" src="/img/HatsuneMiku8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">第01章 准备工作</div></div></a></div><div><a href="/post/fbcbae9d.html" title="第02章 Python语法基础，IPython和Jupyter Notebooks"><img class="cover" src="/img/HatsuneMiku8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-21</div><div class="title">第02章 Python语法基础，IPython和Jupyter Notebooks</div></div></a></div><div><a href="/post/fb496cbf.html" title="第05章 pandas入门"><img class="cover" src="/img/HatsuneMiku8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">第05章 pandas入门</div></div></a></div><div><a href="/post/3be49551.html" title="第03章 Python的数据结构、函数和文件"><img class="cover" src="/img/HatsuneMiku10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">第03章 Python的数据结构、函数和文件</div></div></a></div><div><a href="/post/d2ebab32.html" title="第06章 数据加载、存储与文件格式"><img class="cover" src="/img/HatsuneMiku5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">第06章 数据加载、存储与文件格式</div></div></a></div><div><a href="/post/91c27efb.html" title="第07章 数据清洗和准备"><img class="cover" src="/img/HatsuneMiku10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-22</div><div class="title">第07章 数据清洗和准备</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/EmiyaShirou.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yincha</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wh1720848796" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://gitee.com/wwhhbs" target="_blank" title="Gitee"><i class="fab fa-git" style="color: #EE2C2C;"></i></a><a class="social-icon" href="mailto:1720848796@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信:wh13782 QQ:1720848796</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-GroupBy%E6%9C%BA%E5%88%B6"><span class="toc-text">10.1 GroupBy机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%88%86%E7%BB%84%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="toc-text">对分组进行迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E5%8F%96%E4%B8%80%E5%88%97%E6%88%96%E5%88%97%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-text">选取一列或列的子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E7%BA%A7%E5%88%AB%E5%88%86%E7%BB%84"><span class="toc-text">根据索引级别分组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="toc-text">10.2 数据聚合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%88%97%E7%9A%84%E5%A4%9A%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8"><span class="toc-text">面向列的多函数应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E2%80%9C%E6%B2%A1%E6%9C%89%E8%A1%8C%E7%B4%A2%E5%BC%95%E2%80%9D%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE"><span class="toc-text">以“没有行索引”的形式返回聚合数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-3-apply%EF%BC%9A%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E2%80%9C%E6%8B%86%E5%88%86%EF%BC%8D%E5%BA%94%E7%94%A8%EF%BC%8D%E5%90%88%E5%B9%B6%E2%80%9D"><span class="toc-text">10.3 apply：一般性的“拆分－应用－合并”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%88%86%E7%BB%84%E9%94%AE"><span class="toc-text">禁止分组键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BD%8D%E6%95%B0%E5%92%8C%E6%A1%B6%E5%88%86%E6%9E%90"><span class="toc-text">分位数和桶分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%A8%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%88%86%E7%BB%84%E7%9A%84%E5%80%BC%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-text">示例：用特定于分组的值填充缺失值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-text">示例：随机采样和排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%86%E7%BB%84%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E6%95%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0"><span class="toc-text">示例：分组加权平均数和相关系数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BB%84%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-text">示例：组级别的线性回归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-4-%E9%80%8F%E8%A7%86%E8%A1%A8%E5%92%8C%E4%BA%A4%E5%8F%89%E8%A1%A8"><span class="toc-text">10.4 透视表和交叉表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E8%A1%A8%EF%BC%9Acrosstab"><span class="toc-text">交叉表：crosstab</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-5-%E6%80%BB%E7%BB%93"><span class="toc-text">10.5 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/e04cc1e1.html" title="动手学深度学习中遇到的问题">动手学深度学习中遇到的问题</a><time datetime="2024-11-13T08:57:02.000Z" title="发表于 2024-11-13 16:57:02">2024-11-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/3de4876d.html" title="MySQL数据库之索引">MySQL数据库之索引</a><time datetime="2023-08-04T07:23:35.000Z" title="发表于 2023-08-04 15:23:35">2023-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/6cca3e64.html" title="IDEA64.exe.vmoptions文件详解">IDEA64.exe.vmoptions文件详解</a><time datetime="2023-07-12T08:25:01.000Z" title="发表于 2023-07-12 16:25:01">2023-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/f8e09374.html" title="Vue">Vue</a><time datetime="2023-07-12T07:26:54.000Z" title="发表于 2023-07-12 15:26:54">2023-07-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/67587465.html" title="LeetCode心得笔记">LeetCode心得笔记</a><time datetime="2023-07-12T02:55:37.000Z" title="发表于 2023-07-12 10:55:37">2023-07-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/HatsuneMiku5.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Yincha</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.whfire.top',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.whfire.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="//at.alicdn.com/t/c/font_4022529_htmrp77uopm.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="Hello World,Where there is a will there is a way,Live and Learn" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/01/assets/haru01.model.json"},"display":{"position":"left","width":75,"height":150},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>